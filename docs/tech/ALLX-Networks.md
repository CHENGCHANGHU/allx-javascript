# 网络基础知识

## 0 前言

### 0.1 浏览器与服务器
浏览器与Web服务器之间的朴素交互：
1. 浏览器向Web服务器发送请求
2. Web服务器根据请求向浏览器发送响应  

搬运数字信息的机制，再加上浏览器和Web服务器这些网络应用程序两部分组成了网络  

### 0.2 协议
不同硬件、操作系统之间通信的规则称为协议（protocol），TCP/IP协议族是互联网相关的各类协议族的总称，HTTP协议是TCP/IP协议族内部的子集。 

分层管理，TCP/IP 协议族按层次分别分为以下4 层：应用层、传输层、网络层和数据链路层（应表会传网数物）（应表会传网数物）：
   - **数据链路层**用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。
   - **网络层**用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。
   - **传输层**对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control 
    Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。
   - **应用层**决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。如，FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类。HTTP 协议也处于该层。

IP协议 （Internet Protocol）网际协议，位于网络层，TCP/IP 协议族中的 IP 指的就是网际协议，IP 协议的作用是把各种数据包传送给对方，两个重要的条件是可变的IP 地址和不可变MAC地址（Media Access Control Address），IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和MAC 地址进行配对。

TCP协议 位于传输层，提供可靠的字节流服务，字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理

DNS服务 （Domain Name System）服务是和HTTP 协议一样位于应用层的协议。它提供域名到IP 地址之间的解析服务。DNS 协议提供通过域名查找IP 地址，或逆向从IP 地址反查域名的服务

### 0.3 URL与URI
URL（Uniform Resource Locator）统一资源定位符 正是使用Web 浏览器等访问Web 页面时需要输入的网页地址，Web浏览器根据不同的协议格式对URL进行解析，得到URL的各个组成部分。

URI 是Uniform Resource Identifier 的缩写，URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称，有：http、ftp、telnet、file等。

URI 用字符串标识某一互联网资源，而URL 表示资源的地点（互联网上所处的位置）。可见URL 是URI 的子集。

### 0.4 HTTP协议
HTTP协议定义客户端和服务器之间交互的消息内容和步骤，首先，客户端向服务器发送请求消息（对什么资源+进行怎样操作），其中，对什么资源称为URI（Uniform Resource Indentifier，统一资源标识符），进行怎样操作称为方法/HTTP谓词。然后，服务器对请求消息进行解析，完成操作，将结果存放在响应消息中进行返回。

HTTP 协议自身不对请求和响应之间的通信状态进行保存，即无状态（stateless）协议，使用HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生，有了Cookie 再用HTTP 协议通信，就可以管理状态了。

HTTP 协议使用URI 定位互联网上的资源。正是因为URI 的特定功能，所以在互联网上任意位置的资源都能通过发送请求访问到。

### 0.5 持久连接
HTTP 协议的初始版本中，每进行一次HTTP 通信就要断开一次TCP连接（三四手开销）。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP 连接状态。建立1 次TCP 连接后进行多次请求和响应的交互，减少了TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。HTTP/1.1 中，所有的连接默认都是持久连接。持久连接使得多数请求以管线化（pipelining）方式发送成为可能，不用等待响应亦可直接发送下一个请求，能够做到同时并行发送多个请求，而不需要一个接一个地等待响应。

### 0.6 使用Cookie状态管理
Cookie 技术通过在请求和响应报文中写入Cookie 信息来控制客户端的状态。Cookie 根据服务器端发送的响应报文内 **Set-Cookie** 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，**客户端会自动在请求报文中加入Cookie 值后发送出去**。服务器端收到客户端发送过来的Cookie 后，会去检查是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

### 0.8 HTTP缓存
[参考文章](https://www.cnblogs.com/echolun/p/9419517.html)  
HTTP缓存主要针对CSS、JS、图片等更新频率低的静态文件，避免重复下载资源，加快页面渲染，提升用户体验。  

通用首部字段（请求和响应都使用）Cache-Control
缓存请求指令：  
|指令|参数|说明|
|:-|:-|:-|
|**no-cache**| 无 |**强制向源服务器再次验证**|
|**no-store**| 无 |**不缓存请求或响应的任何内容**|
|max-age = [秒]| 必需 |响应的最大Age值|
|max-stale( = [秒])| 可省略|接收已过期的响应|
|min-fresh = [秒]| 必需|期望在指定时间内的响应仍有效|
|no-transform| 无|代理不可更改媒体类型|
|only-if-cached| 无|从缓存获取资源|
|cache-extension| - |新指令标记（token）|
缓存响应指令：  
|指令|参数|说明|
|:-|:-|:-|
|public| 无|可向任意方提供响应的缓存|
|private| 可省略|仅向特定用户返回响应|
|no-cache| 可省略|缓存前必须先确认其有效性|
|no-store| 无|不缓存请求或响应的任何内容|
|no-transform| 无|代理不可更改媒体类型|
|must-revalidate| 无|可缓存但必须再向源服务器进行确认|
|proxy-revalidate| 无|要求中间缓存服务器对缓存的响应有效性再进行确认|
|max-age = [秒]| 必需|响应的最大Age值|
|s-maxage = [秒]| 必需|公共缓存服务器响应的最大Age值|
|cache-extension| - |新指令标记（token）|

- 事实上，no-cache目的在于防止使用缓存中过期资源，所以每次请求缓存时，中间缓存服务器必须先向源服务器发送请求确认有效性；no-store则是完全不缓存、不存储，规定缓存不能在本地存储请求或响应的任一部分

相关首部字段
   - Expires：响应首部字段，资源过期时间，优先级低于Cache-Control中max-age指令
   > 1）Expires是http 1.0的属性，绝对过期时间（GMT格式），为了向下兼容，所以会写上
   > 2）max-age是http 1.1的属性，相对过期时间（相对请求成功），在http 1.1情况下优先级更高
   - Last-Modified：响应首部字段，资源最新修改时间
   - if-Modified-Since：请求首部字段，资源最新修改时间，传递给服务器与Last-Modified进行对比，未修改则304，使用本地缓存
   - Etag：响应首部字段，缓存资源标识
   - if-None-Match：请求首部字段，缓存资源标识，传递给服务器与Etag进行对比，未修改则304，使用本地缓存

缓存流程（浏览器向服务器请求资源）：
   > 第一次浏览器向服务器请求资源，未使用缓存，服务器返回 资源 + Expires + Last-Modified
   1. 浏览器核验Expires时间，未过期，不发起请求，使用本地缓存，过期则重新请求资源；
      > 如果Expires过期，但文件未做修改，且浏览器可以随意修改Expires，则需要if-Modiyied-Since及if-None-Match做进一步核验来避免重复请求
   2. 浏览器携带资源最新修改时间if-Modiyied-Since首部字段，服务器将之与Last-Modiyied对比，相同则304，通知浏览器使用本地缓存，否则重新发送资源；
      > Last-Modiyied精度只能精确到秒，如果文件在一秒内发生改动，则浏览器无法获取最新资源，则需要if-None-Match做进一步核验来避免重复请求
   3. 浏览器携带资源标识if-None-Match首部字段，服务器将之与Etag对比，相同则304，通知浏览器使用本地缓存，否则重新发送资源；
      > Etag优先级比Last-Modified高，因为更精准

存在问题：   
   如果Cache-Control中max-age与Expires不过期，则浏览器就无法获取最新资源  
HTTP缓存方案：
|方法|操作|原理|
|:-:|:-|:-|
|md5/hash缓存|不缓存html，为静态资源文件名添加md5或hash标识，使得浏览器忽略缓存过期时间获取最新资源|静态资源文件名不同，则URI不同，即会重新获取资源，不缓存HTML保证了每次都会验证html中引用的静态资源是否有更新|
|CDN缓存|CDN边缘节点缓存数据，当浏览器请求，CDN节点代替源服务器判断并处理此请求|CDN是内容分发网络，通过分流降低网络拥塞从而实现加速目的，缓存本身是针对更新频率不高的静态资源，且CDN可以手动更新缓存，解决了浏览器缓存无法控制的问题|

浏览器操作对缓存的影响
|浏览器操作|Expires/Cache-Control(max-age)|Last-Modified/Etag|
|:-:|:-:|:-:|
|地址栏回车|生效|生效|
|页面链接跳转|生效|生效|
|新开窗口|生效|生效|
|页面前进、后退|生效|生效|
|F5刷新、浏览器刷新|忽略|生效|
|Ctrl+F5强制刷新|忽略|忽略|

地址栏回车、页面链接跳转、新开窗口、页面前进后退操作会先判断缓存资源是否过期，其次再是核验资源修改时间和缓存资源标识；F5刷新、浏览器刷新操作跳过判断缓存资源是否过期，直接核验资源修改时间和缓存资源标识；Ctrl+F5强制刷新，跳过判断缓存资源是否过期，忽略资源修改时间和缓存资源标识，直接重新请求静态资源文件。

多数网站都将Cache-Control设置为no-cache，此时，会缓存静态资源，但是使用缓存前会无条件地向服务器发起请求，核验缓存资源是否为最新资源，但是仍有必要设置Expires和max-age，因为关闭一个页面之后，再次打开属于新开窗口行为，则新开窗口走强缓存，可以避免重复下载资源、加快页面渲染、提升用户体验。
> 1）强缓存：不发起HTTP请求，直接使用本地缓存  
> 2）协商性缓存：使用本地缓存之前，发起HTTP请求，与服务器协商，核验缓存的资源是否为最新资源，如设置了no-cache指令的缓存为协商性缓存

### 0.9 浏览器存储数据

#### 0.9.1 Cookie
Cookie有服务器使用Set-Cookie首部字段设置，浏览器在每次对相同域的请求时自动携带在Cookie首部字段中。Cookie一般大小不超过4KB，每个域的cookie总数不超过20个，document.cookie是一个访问器，可以读取或设置。

**domain指令**：domain=site.com，默认 cookie 仅在当前域下可见，如果显式设置了域，可以使 cookie 在子域下也可见。

**expires、max-age指令**：如果没有设置expires（绝对时间，区别于Expires首部字段，这里是Set-Cookie响应首部字段的指令）或max-age（相对时间，单位为秒，0或负数则立即过期），则浏览器关闭后，cookie将消失，此种cookie称为session cookie。

**samesite指令**：旨在防止XSRF攻击。samesite取值有strict（严格，默认值）和lax（宽松），如果设置为strict，则来自不同网站的cookie不会被发送，但此时通过正常网站也不能携带cookie，可以通过设置两个cookie来解决这个问题，一个cookie用于身份验证，一个有samesite=strict指令的cookie用于数据操作。如果设置为lax，当从其他网站访问本网站禁止携带Cookie，但满足以下条件：1）安全Http方法（读取而非写入）；2）操作执行顶级导航（更改浏览器地址栏中的URL）之一也可携带Cookie
> XSRF攻击：登录A网站，浏览器存储来自A网站的身份验证Cookie，每次请求都会带上该Cookie，此时，若新开一个页面访问B网站，B网站中有action为A网站的表单，则提交这个表单，会携带上A网站的身份验证cookie，从而B网站可以实现对A网站的攻击

**HttpOnly指令**：禁止任何JS脚本访问cookie，document.cookie将访问不到此类cookie，于是也不能操作。

#### 0.9.2 Web存储对象LocalStorage、SessionStorage
Web存储对象 localStorage 和 sessionStorage 可以在浏览器上保存键/值对，页面刷新后localStorage和浏览器重启sessionStorage后仍然保留在浏览器中。Web存储对象不会跟随请求发送到服务器，服务器无法通过首部字段控制web存储对象，仅通过JS控制，存储数据有同源限制（协议+域名+端口）。

相同的方法和属性：setItem(key, value)、getItem(key)、removeItem(key)、clear()、key(index)、length属性。**注意：键和值都是字符串**
> 可以使用类似类属性方式读取和设置值：`localStorage[key] = value`，不建议如此做  
> 遍历：
   ```js
   for(let i = 0; i < localStorage.length; i++) {
      let key = localStorage.key(i);
      alert(`${key}: ${localStorage.getItem(key)}`);
   }
   ```     

LocalStorage：绑定到源，在同源（路径可以不同，源需要相同）的标签页和窗口之间共享数据，数据不会过期，在浏览器甚至系统重启后仍然存在  
SessionStorage：绑定到源和同一浏览器标签页，数据只存在于当前浏览器标签页，相同地址的另一个标签页的存储不同，数据在当前页面刷新后仍然存在，但在关闭/重新打开浏览器标签页后不会保留（所以使用较少）

Web存储对象的Storage事件：监听Web存储对象的数据变动，在所有可访问到该存储对象的window对象上触发，导致数据变动的window对象除外，这允许了同源的不同窗口间交换消息。

#### 0.9.3 IndexedDB

IndexedDB is a database that is built into browser

## 1 Web浏览器

### 1.1 生成HTTP请求消息
用于HTTP 协议交互的信息被称为HTTP 报文，由多行（用CR+LF 作换行符）数据构成的字符串文本，HTTP 报文大致可分为报文首部和报文主体两块，但并不一定要有报文主体。

请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成  

<table>
   <thead>
      <td>报文种类</td>
      <td>组成部分</td>
      <td>说明</td>
   </thead>
   <tr>
      <td rowspan='4'>请求报文结构</td>
      <td>请求行</td>
      <td>包含用于请求的方法，请求URI 和HTTP 版本</td>
   </tr>
   <tr>
      <table style="border: none;">
         <tr style="border: none;">
            <td style="border: none;" rowspan='4'>首部字段</td>
            <td style="border: none;">请求首部字段</td>
         </tr>
         <tr>
            <td style="border: none;">通用首部字段</td>
         </tr>
         <tr>
            <td style="border: none;">实体首部字段</td>
         </tr>
         <tr>
            <td style="border: none;">其他</td>
         </tr>
      </table>
      <td>其他包含表示请求的各种条件和属性的各类首部，其他可能包含HTTP 的RFC 里未定义的首部（Cookie 等）</td>
   </tr>
   <tr>
      <td>空行（CR+LF）</td>
      <td></td>
   </tr>
   <tr>
      <td>报文主体</td>
      <td></td>
   </tr>
   <tr>
      <td rowspan='4'>响应报文结构</td>
      <td>状态行</td>
      <td>包含表明响应结果的状态码，原因短语和HTTP 版本</td>
   </tr>
   <tr>
      <table style="border: none;">
         <tr style="border: none;">
            <td style="border: none;" rowspan='4'>首部字段</td>
            <td style="border: none;">响应首部字段</td>
         </tr>
         <tr>
            <td style="border: none;">通用首部字段</td>
         </tr>
         <tr>
            <td style="border: none;">实体首部字段</td>
         </tr>
         <tr>
            <td style="border: none;">其他</td>
         </tr>
      </table>
      <td>其他包含表示响应的各种条件和属性的各类首部，其他可能包含HTTP 的RFC 里未定义的首部（Cookie 等）</td>
   </tr>
   <tr>
      <td>空行（CR+LF）</td>
      <td></td>
   </tr>
   <tr>
      <td>报文主体</td>
      <td></td>
   </tr>
</table>

HTTP谓词/方法（8种）：
1. GET ：获取资源
   - 请求访问已被URI 识别的资源，指定的资源经服务器端解析后返回响应内容
   - 如果请求的资源是文本，那就保持原样返回
   - 如果是像CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果
2. POST：传输实体主体
   - 用来传输实体的主体
   - 主要目的并不是获取响应的主体内容
3. PUT：传输文件
   - 就像FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI 指定的位置
   - HTTP/1.1 的PUT 方法自身不带验证机制，任何人都可以上传文件, 存在安全性问题，因此一般的Web 网站不使用该方法
   - 若配合Web 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类Web 网站，就可能会开放使用PUT 方法
4. HEAD：获得报文首部
   - HEAD 方法和GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等
5. DELETE：删除文件
   - DELETE 方法用来删除文件，是与PUT 相反的方法。DELETE 方法按请求URI 删除指定的资源
   - HTTP/1.1 的DELETE 方法本身和PUT 方法一样不带验证机制，所以一般的Web 网站也不使用DELETE 方法。当配合Web 应用程序的验证机制，或遵守REST 标准时还是有可能会开放使用
6. OPTIONS：询问支持的方法
   - 查询针对请求URI 指定的资源支持的方法
7. TRACE：追踪路径
   - 让Web 服务器端将之前的请求通信环回给客户端的方法
   - 容易引发XST（Cross-Site Tracing，跨站追踪）攻击，通常不会用到
8. CONNECT：要求用隧道协议连接代理
   - 要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP 通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输

```
请求消息 = 请求行 + 消息头 + 空行 + 消息体  
响应消息 = 状态行 + 消息头 + 空行 + 消息体  
```

浏览器获得响应数据后，将其提取并显示在屏幕上，如果网页中包含图片，则嵌入表示图片文件标签的控制信息，浏览器显示文字时，遇到图片标签则先留出显示图片的空间，然后再次访问web服务器获取图片数据进行显示。由于每条请求消息中只能写1个URI，所以每次只能获取一个文件，获取多个文件则发送多次请求。

### 1.2 从DNS服务器查询web服务器的IP地址
生成HTTP请求消息之后，浏览器委托操作系统将消息发送给Web服务器  

IP地址/子网掩码：子网掩码前半部分全1，后半部分全0，因此将IP地址分割为网络号和主机号，主机号全0代表整个子网，全1代表广播。  

计算机包含DNS客户端，才能向DNS服务器发送查询消息，计算机上作为DNS客户端的是DNS解析器，解析器包含在操作系统的Socket库（调用网络功能的程序组件集合）中。  

发送查询消息的操作也不是由解析器自身执行，而是委托给操作系统内部的协议栈，协议栈执行发送消息的操作，然后通过网卡将消息发送给DNS服务器。  

向DNS服务器发送消息时，也需要知道DNS服务器的IP地址，这个地址一般都会预设好。

### 1.3 DNS服务器的工作
基本工作：接收来自客户端的查询消息，根据消息内容返回响应。DNS服务器从域名和IP地址的对照表中查找相应的记录，并返回IP地址。

域名中，越靠右，层级越高，按照点号分割域名，分成一级级的域，通常将一层域的整个信息存放在一台DNS服务器中，但一台DNS服务器可以存放多个层级域的信息。

DNS服务器的层级关系：将负责管理下级域的DNS服务器IP地址注册到上一级DNS服务器中，以此类推，直到根域，构成DNS服务器的层级关系，再将根域的DNS服务信息保存在互联网的所有DNS服务器中，从根域向下查找子域直至找到域名相应的IP地址。
> 根域：域名最后的点号，一般不写。

通过缓存可以加快DNS服务器的响应

### 1.4 委托协议栈发送消息

1、创建套接字
2、将管道连接到服务器端的套接字上
3、收发数据
4、断开管道并删除套接字

数据流通管道两端的数据出入口称为套接字，先创建套接字，再将套接字连接起来形成管道。通过IP地址和端口号可以唯一确定一个套接字。描述符可以在计算机内部确定一个套接字，IP地址和端口号可以让通信的双方确定套接字。

## 2 协议栈、网卡

### 2.1 创建套接字

协议栈：网络控制软件  
网卡：网络硬件

浏览器、邮件等收发数据使用TCP  
DNS查询等收发较短的控制数据使用UDP  

套接字是一个概念，可以说存放了控制通信操作的控制信息（如：通信对象的IP地址、端口号、通信操作状态等）的内存空间就是套接字的实体。协议栈根据套接字中存储的信息进行下一步操作。

应用程序在向协议栈进行收发数据委托时需要提供包含初始控制信息的套接字描述符，协议栈才知晓通信对方信息。

### 2.2 连接服务器

目的：把服务器的IP地址和端口号等信息告知协议栈；客户端请求与服务器开始通信。

具体含义：通行双方交换控制信息，以及分配收发数据的缓冲区等通信前的准备都是连接操作的具体含义。更确切的说，连接更应该被称为准备。

建立连接之后，协议栈的连接操作就结束了，控制流程交回应用程序。

### 2.3 收发数据

MTU：Maximum Transformission Unit 最大传输单元，一个网络包的最大长度，以太网中一般为1500字节（包含头部）  
MSS：Maximum Segment Size 最大分段大小，不包含头部的网络包数据最大长度，一般为1460字节（TCP、IP头部一般是40字节）

当从应用程序收到的数据长度超过或接近MSS时，再发送数据，可以避免发送大量小包的问题；但是等待缓冲区数据长度接近MSS，需要耗费时间，同样影响响应时间，所以需要平衡两者，同时协议栈也给应用程序保留了控制发送时机的机会。

当数据长度超过MSS时，需要进行拆分。

发送方需要拆分数据包时，计算每一个数据分包的第一个字节距离原数据包起始位置的字节数，记在TCP头部的序号字段中，发送的数据分包长度无需记录，接收方用整个网络包的长度减去头部长度可得，接收方将收到的数据分包总字节数加1填入响应TCP包头部的ACK字段，用以确认响应。
> 实际中，序号从一个随机数值开始，避免通信过程可预测。

TCP在得到通信对方的确认报文之前，依旧将已发送的数据保留在发送缓冲区中，如果没有得到确认报文，则会重新发送。这一补偿机制是TCP的强大之处，从而网卡、集线器、路由器等都不再有错误补偿机制。TCP会在多次重传无效之后强制结束通信，并向应用程序报错。

根据网络包平均往返时间动态调整ACK号等待时间  

滑动窗口：发送一个数据包后，不等待ACK号，直接发送后续的一系列包，为避免接收方来不及处理已接收数据，接收方通过TCP头部的窗口字段将自己能接收的数据量告知发送方，即为窗口大小。

实际上没必要每次都向发送方更新窗口大小，发送方在每次发送数据时减去已发送的数据长度即可自行计算出当前窗口大小。所以更新窗口大小的时机应该是接收方应用程序从缓冲区取出数据的时候，此时窗口大小变大。从另一方面看，变小是由于发送方填入数据，变大是由于应用程序取出数据，变小发送方可知，变大不可知，所以需要在变大的时候更新窗口。

接收方在发送ACK和窗口更新时，并不会立马把包发送出去，而是等待一段时间，将其他通知合并到一起发送。连续发送ACK时，可以只发送最后一个，以为是连续的，同样，连续发送窗口更新的时候，也可以只发送最后一个窗口更新。

### 2.4 从服务器断开并删除套接字

### 2.5 IP与以太网的包收发操作

集线器按照以太网规则传输包，路由器按照IP规则传输包。IP协议根据目标地址判断下一个IP转发设备的位置，子网中的以太网协议将包传输到下一个转发设备。

TCP/IP包包含两个头部：MAC头部（以太网协议）、IP头部（IP协议）

发送方将接收方IP地址写入IP头部中，IP协议根据这一地址查找包的传输方向，从而找到下一个路由器的位置。之后IP协议委托以太网协议将包传输过去，IP协议查找下一个路由器的以太网地址（MAC地址）写入MAC头部，以太网协议据此传输包到下一个路由器。

IP协议负责寻址，以太网协议负责传输，分开就可以替换不同的传输协议。

包收发操作的起点是TCP模块委托IP模块发送包的操作。

IP地址实际上是分配给网卡的。

通过ARP协议查询目标路由器的MAC地址，ARP，Address Resolution Protocol，地址解析协议。ARP协议就是通过广播在子网中查询，ARP缓存可以避免每次查询的广播，但为避免保存的地址发生变化，需要定时强制删除缓存，再进行一次ARP查询。

### 2.6 UDP协议的收发操作

向DNS服务器查询IP地址时使用的是UDP协议。

将从应用程序获取的数据加上UDP头部，发送给指定的IP地址即可，不需要交换控制信息，不需要建立和断开连接的步骤。

控制用的短数据、音视频数据

## 3 集线器、交换机、路由器

### 3.1 信号在网线和集线器中传输

包独立传输：HTTP请求方法、TCP的序号和ACK、客户端与服务器的关系都与包的传输无关。

### 3.2 交换机的包转发操作

### 3.3 路由器的包转发操作

路由器忽略主机号，只匹配网络号

路由聚合，聚合多个子网，减少路由表中记录数量



## 4 接入网、网络运营商  

距离的不同和路由的维护方式，是互联网与家庭、公司网络之间最主要的不同点


## 5 防火墙、缓存服务器
## 6 Web服务器

### 6.1 HTTP响应状态码
HTTP 状态码负责表示客户端HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。状态码类别有：  
|  | 状态码 | 分类 | 含义 |
| :-  | :-: | :- | :- |
| 1 | 1XX | Informational（信息性状态码） | 接收的请求正在处理 |
| 2 | 2XX | Success（成功状态码） | 请求正常处理完毕 |
| 3 | 3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求 |
| 4 | 4XX | Client Error（客户端错误状态码） | 服务器无法处理请求 |
| 5 | 5XX | Server Error（服务器错误状态码） | 服务器处理请求出错 |

#### 6.1.1 2XX 成功
表明请求被正常处理
- 200 OK：表示从客户端发来的请求在服务器端被正常处理
- 204 No Content：代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体
- 206 Partial Content：表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由Content-Range 指定范围的实体内容

#### 6.1.2 3XX 重定向
表明浏览器需要执行某些特殊的处理以正确处理请求
- 301 Moved Permanently：永久性重定向，表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI
- 302 Found：临时性重定向，表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI 访问
- 303 See Other：表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源
> 301、302、303响应返回后，浏览器会将POST改为GET，删除请求报文主体部分，再次请求 
- 304 Not Modified：表示服务器允许请求访问，但不满足请求中附带条件（如：If-Match、If-Modified-Since等），此时返回的响应不包含主体部分
- 307 Temporary Redirect：临时重定向，与302有相同含义，遵照浏览器标准，不会从POST改为GET

#### 6.1.3 4XX 客户端错误
表明客户端是发生错误的原因所在
- 400 Bad Request：表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求
- 401 Unauthorized：表示发送的请求需要有通过HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息
- 403 Forbidden：表明对请求资源的访问被服务器拒绝了
- 404 Not Found：表明服务器上无法找到请求的资源
- 408 请求超时

#### 6.1.4 5XX 服务器错误
表明服务器本身发生错误
- 500 Internal Server Error：表明服务器端在执行请求时发生了错误
- 503 Service Unavailable：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求
- 504 网关超时

## 7 HTTP2
基于SPDY协议  

### 7.1 二进制传输
不再是Http1.x的文本格式

### 7.2 多路复用

### 7.3 Header压缩

### 7.4 服务端推送

### 7.5 HTTP3

http-over-quic  
QUIC协议基于UDP

## 8 SSL/TLS工作原理

[参考链接](https://zhuanlan.zhihu.com/p/141258634)

> Secure Socket Layer、Transport Layer Security  
> 非对称加密RSA：公钥+私钥，一个钥加密，另一个钥解密  

### 8.1 公私钥加密通信
A、B 各有自己的公私钥（puk、prk 根据特定算法生成），prk 保存在本地，puk 传递给对方（假设已经安全传递给对方）。A 传递数据给 B 时，先使用 A 的 prk 加密数据摘要的哈希值 h1 形成数字签名 s1，然后将数据（密码等敏感信息也需要加密）和数字签名 s1 再使用随机生成的DES密钥（对称加密）des1 进行加密得到密文 m1，最后使用 B 的 puk 加密 des1 再连同密文 m1 传递给 B。B 收到加密后的 des1 和密文之后，先使用 B 的 prk 解密得到DES密钥 des1，使用 des1 解密密文得到数据和数字签名，本地运算得出数据摘要的哈希值 h2，再用 A 的 puk 解密转递来数字签名得到 A 计算的数据摘要的哈希值 h3，对比 h2 和 h3，以检验数据的完整性。（如此这般，中间人攻击依旧存在）

![公私钥加密通信](../../flowcharts/tls.png)

### 8.2 中间人攻击
中间人攻击：A、B 的 puk 需要传递给对方，如果中间人 C 截获 A、B 的 puk，把 C 的 puk 传递给 A、B，那么 A、B 就会使用 C 的 puk 加密数据，C 在之后的 A、B 传递数据时，继续截获数据，解密后篡改数据，再使用 C 的 prk 加密数据，A、B 将无法验证数据真实性，除非 A、B 当面交接 puk（显然不可行）。

### 8.3 CA系统
CA（Certificate Authority）证书颁发机构：用以保证 puk 的真实性，CA 将自己的 puk 集成在浏览器和操作系统中，避免通过网络传输遭受中间人攻击。CA 同样基于非对称加密工作，B 将自己的 puk 和必要信息使用 CA 的 puk 加密再传递给 CA，CA 用 CA 的 prk 加密这些数据，就得出 B 的数字证书，B向A传递B的数字证书，而不是B的puk，A收到B的数字证书后，使用CA的puk解密收到的数据，才得到B的puk（同理，B也可以得到A的puk），两边即可通信数据。

实际中，CA认证需要收费，Web服务器会做CA认证，普通用户不会去做CA认证，所以用户浏览器想Web服务器请求安全连接，服务器传递自己的数字证书，浏览器使用CA内置的公钥解密数据得到服务器的公钥，然后使用公钥加密需要传递的数据，因此可以保证服务器的真实性，但用户端的真实性无法保证，因此需要用户账号和密码保证用户的真实性。

SSL/TLS工作流程（TCP建立连接之后）：  
1）客户端发送ClientHello消息到服务器，ClientHello消息包括：客户端支持的SSL/TLS版本、客户端支持的加密套件、session id、随机数client random  
2）服务器收到ClientHello消息，选择SSL/TLS版本、加密套件，发送ServerHello消息到客户端，ServerHello消息包括：服务器支持的SSL/TLS最高版本、服务器选择的加密套件、session id、随机数server random、服务器的数字证书（使用CA的prk加密后的服务器puk和服务器必要信息）  
3）客户端收到ServerHello消息后，验证服务器的数字证书（校验hash值、数字证书中服务器名称和数字证书过期时间），验证通过则生成随机数pre master，客户端使用数字证书中的服务器puk加密pre master生成密文传递给服务器，并且在本地按照F(client random + server random + pre master)的方式生成master secret作为后续对称加密通信的密钥  
4）服务器收到客户端传递的消息，使用服务器的prk解密消息，得到pre master，同样按照F(client random + server random + pre master)的方式生成master secret作为后续对称加密通信的密钥  
5）客户端使用master secret加密握手完成的消息发送给服务器  
6）服务器使用master secret加密握手完成的消息回发给客户端，握手结束。
> client random、server random都与时间相关联，保证了master secret一定是随机数  



---
# 图解HTTP

## Web及网络基础


### 网络基础

### URI

## HTTP/1.1协议

### 

### HTTP方法

## HTTP通信过程


### 编码

- 报文
  实体

  - 报文（message）是HTTP 通信中的基本单位，由8 位组字节流（octet sequence，其中octet 为8 个比特）组成，通过HTTP 通信传输
  - 实体（entity）作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成
  - HTTP 报文的主体用于传输请求或响应的实体主体
  - 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异

- 内容编码

  - 内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码
  - 常用的内容编码：
    gzip（GNU zip）
    compress（UNIX 系统的标准压缩）
    deflate（zlib）
    identity（不进行编码）

- 分块传输编码

  - 在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面，这种把实体主体分块的功能称为分块传输编码（Chunked Transfer
    Coding）
  - HTTP/1.1 中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中

### 多部分对象集合

- 在MIME 扩展中使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据
- MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据，如，图片等二进制数据以ASCII 码字符串编码的方式指明，就是利用MIME 来描述标记数据类型
- HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用，需要在首部字段里加上Content-type

### 部分内容范围请求

- 指定下载的实体范围，实现恢复，能从之前下载中断处恢复下载，指定范围发送的请求叫做范围请求（Range Request），用到首部字段Range 来指定资源的byte 范围
- 针对范围请求，响应会返回状态码为206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段ContentType标明multipart/byteranges 后返回响应报文
- 如果服务器端无法响应范围请求，则会返回状态码200 OK 和完整的实体内容

### 内容协商

- 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准
- 首部字段：
  Accept
  Accept-Charset
  Accept-Encoding
  Accept-Language
  Content-Language
- 内容协商技术：
  服务器驱动协商（Server-driven Negotiation）
  客户端驱动协商（Agent-driven Negotiation）
  透明协商（Transparent Negotiation）


## Web服务器

### 一台Web 服务器可搭建多个独立域名的Web 网站，也可作为通信路径上的中转服务器提升传输效率

### 单台虚拟主机实现多个域名

- 互联网上，域名通过DNS 服务映射到IP 地址（域名解析）之后访问目标网站。可见，当请求发送到服务器时，已经是以IP 地址形式访问了
- 在相同的IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web 网站，因此在发送HTTP 请求时，必须在Host 首部内完整指定主机名或域名的URI

### 通信数据转发

- 用于通信数据转发的应用程序，配合服务器工作
- 代理

  - 一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端
  - 用途：利用缓存技术减少网络带宽的流量、组织内部针对特定网站的访问控制、以获取访问日志为主要目的
  - 缓存代理：
    代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回
  - 透明代理：
    转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。

- 网关

  - 转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关
  - 网关能使通信线路上的服务器提供非HTTP 协议服务；利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全

- 隧道

  - 在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL 等加密手段进行通信
  - 目的是确保客户端能与服务器进行安全的通信
  - 隧道本身不会去解析HTTP 请求。请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束

### 资源缓存

- 缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间
- 缓存服务器是代理服务器的一种，并归类在缓存代理类型中
- 利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了
- 缓存的有效期
- 客户端缓存
  - 浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取
  - 当判定缓存过期后，会向源服务器确认资源的有效性

## HTTP首部

### 首部内容为客户端和服务器分别处理请求和响应提供所需要的信息

### 首部字段

- 传递额外重要信息
- 结构：首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔
  首部字段名: 字段值
  Content-Type: text/html

### 类型

HTTP/1.1 47

- 通用首部字段（General Header Fields）
- 请求首部字段（Request Header Fields）
- 响应首部字段（Response Header Fields）
- 实体首部字段（Entity Header Fields）

### 通用首部

HTTP/1.1  

- ·Cache-Control 控制缓存的行为
  ·Connection 逐跳首部、连接的管理
  ·Date 创建报文的日期时间
  ·Pragma 报文指令
  ·Trailer 报文末端的首部一览
  ·Transfer-Encoding 指定报文主体的传输编码方式
  ·Upgrade 升级为其他协议
  ·Via 代理服务器的相关信息
  ·Warning 错误通知
- Cache-Control

  - 操作缓存的工作机制
  - 指令的参数是可选的，多个指令之间通过“,”分隔
  - 缓存请求指令：
    ·no-cache --无--强制向源服务器再次验证
    ·no-store --无--不缓存请求或响应的任何内容
    ·max-age = [ 秒] --必需--响应的最大Age值
    ·max-stale( = [ 秒]) --可省略--接收已过期的响应
    ·min-fresh = [ 秒] --必--需期望在指定时间内的响应仍有效
    ·no-transform --无--代理不可更改媒体类型
    ·only-if-cached --无--从缓存获取资源
    ·cache-extension - 新指令标记（token）
  - 缓存响应指令：
    ·public --无--可向任意方提供响应的缓存
    ·private --可省略--仅向特定用户返回响应
    ·no-cache --可省略--缓存前必须先确认其有效性
    ·no-store --无--不缓存请求或响应的任何内容
    ·no-transform --无--代理不可更改媒体类型
    ·must-revalidate --无--可缓存但必须再向源服务器进行确认
    ·proxy-revalidate --无--要求中间缓存服务器对缓存的响应有效性再进行确认
    ·max-age = [ 秒] --必需--响应的最大Age值
    ·s-maxage = [ 秒] --必需--公共缓存服务器响应的最大Age值
    ·cache-extension - 新指令标记（token）

### 请求首部

HTTP/1.1 

- ·Accept 用户代理可处理的媒体类型
  ·Accept-Charset 优先的字符集
  ·Accept-Encoding 优先的内容编码
  ·Accept-Language 优先的语言（自然语言）
  ·Authorization Web认证信息
  ·Expect 期待服务器的特定行为
  ·From 用户的电子邮箱地址
  ·Host 请求资源所在服务器
  ·If-Match 比较实体标记（ETag）
  ·If-Modified-Since 比较资源的更新时间
  ·If-None-Match 比较实体标记（与If-Match 相反）
  ·If-Range 资源未更新时发送实体Byte 的范围请求
  ·If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反）
  ·Max-Forwards 最大传输逐跳数
  ·Proxy-Authorization 代理服务器要求客户端的认证信息
  ·Range 实体的字节范围请求
  ·Referer 对请求中URI 的原始获取方
  ·TE 传输编码的优先级
  ·User-Agent HTTP 客户端程序的信息

### 响应首部

HTTP/1.1 

- Accept-Ranges 是否接受字节范围请求
  Age 推算资源创建经过时间
  ETag 资源的匹配信息
  Location 令客户端重定向至指定URI
  Proxy-Authenticate 代理服务器对客户端的认证信息
  Retry-After 对再次发起请求的时机要求
  Server HTTP服务器的安装信息
  Vary 代理服务器缓存的管理信息
  WWW-Authenticate 服务器对客户端的认证信息

### 实体首部

HTTP/1.1 

- Allow 资源可支持的HTTP方法
  Content-Encoding 实体主体适用的编码方式
  Content-Language 实体主体的自然语言
  Content-Length 实体主体的大小（单位：字节）
  Content-Location 替代对应资源的URI
  Content-MD5 实体主体的报文摘要
  Content-Range 实体主体的位置范围
  Content-Type 实体主体的媒体类型
  Expires 实体主体过期的日期时间
  Last-Modified 资源的最后修改日期时间

### 非HTTP/1.1 首部字段

- 还有Cookie、Set-Cookie 和Content-Disposition等在其他RFC 中定义的首部字段，它们的使用频率也很高

### 端到端首部（End-to-end Header）

- 此类别中的首部会转发给请求/ 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发

### 逐跳首部（Hop-by-hop Header）

- 此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用hop-by-hop 首部，需提供Connection 首部字段
- HTTP/1.1 中的逐跳首部字段：
  Connection
  Keep-Alive
  Proxy-Authenticate
  Proxy-Authorization
  Trailer
  TE
  Transfer-Encoding
  Upgrade

### cookie相关首部

- Set-Cookie

  - 开始状态管理所使用的Cookie信息
  - 1）NAME=VALUE：赋予Cookie 的名称和其值（键值对，必需项）
    2）expires=DATE：Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）
    3）path=PATH：将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）
    4）domain=域名：作为Cookie 适用对象的域名（若不指定则默认为创建Cookie的服务器的域名）
    5）Secure：仅在HTTPS 安全通信时才会发送Cookie
    6）HttpOnly：加以限制，使Cookie 不能被JavaScript 脚本访问

- Cookie

  - 服务器接收到的Cookie信息

### 其他首部

- X-Frame-Options

  - 响应首部，用于控制网站内容在其他Web 网站的Frame 标签内的显示问题。其主要目的是为了防
    止点击劫持（clickjacking）攻击
    DENY：拒绝
    SAMEORIGIN：允许同源页面匹配

- X-XSS-Protection

  - 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器XSS 防护机制的开关
    0 ：将XSS 过滤设置成无效状态
    1 ：将XSS 过滤设置成有效状态

- DNT 

  - 请求首部，Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法
    0 ：同意被追踪
    1 ：拒绝被追踪

## HTTPS

### 通信使用明文（不加密），内容可能会被窃听

不验证通信方的身份，因此有可能遭遇伪装
无法证明报文的完整性，所以有可能已遭篡改

- 加密处理防止被窃听

  - 通信加密

    - 与SSL结合，形成HTTPS（HTTP Secure，超文本传输安全协议）

  - 内容加密

    - 加密HTTP报文主体内容

- 查明对方证书
- 防篡改校验

### HTTPS=HTTP+加密+认证+完整性保护

---
参考书籍：《图解HTTP》、《网络是怎样连接的》

---

