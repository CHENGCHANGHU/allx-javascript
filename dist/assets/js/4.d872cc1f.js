(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{348:function(t,_,a){t.exports=a.p+"assets/img/tls.b9b666e1.png"},357:function(t,_,a){"use strict";a.r(_);var r=a(42),s=Object(r.a)({},(function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"网络是怎样连接的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#网络是怎样连接的"}},[t._v("#")]),t._v(" 网络是怎样连接的")]),t._v(" "),r("p",[t._v("浏览器与Web服务器之间的朴素交互：")]),t._v(" "),r("ol",[r("li",[t._v("浏览器向Web服务器发送请求")]),t._v(" "),r("li",[t._v("Web服务器根据请求向浏览器发送响应")])]),t._v(" "),r("p",[t._v("搬运数字信息的机制，再加上浏览器和Web服务器这些网络应用程序两部分组成了网络")]),t._v(" "),r("h2",{attrs:{id:"_1-web浏览器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-web浏览器"}},[t._v("#")]),t._v(" 1 Web浏览器")]),t._v(" "),r("h3",{attrs:{id:"_1-1-生成http请求消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-生成http请求消息"}},[t._v("#")]),t._v(" 1.1 生成HTTP请求消息")]),t._v(" "),r("p",[t._v("URL：Uniform Resource Locator，统一资源定位符。URL根据http、ftp、file等协议进行分类，协议不同，URL格式也随之不同，Web浏览器根据这些不同的协议格式对URL进行解析，得到URL的各个元素。")]),t._v(" "),r("p",[t._v("HTTP协议定义客户端和服务器之间交互的消息内容和步骤。首先，客户端向服务器发送请求消息（对什么资源+进行怎样操作），其中，对什么资源称为URI（Uniform Resource Indentifier，统一资源标识符），进行怎样操作称为方法/HTTP谓词。然后，服务器对请求消息进行解析，完成操作，将结果存放在响应消息中进行返回。")]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("请求消息 = 请求行 + 消息头 + 空行 + 消息体  \n响应消息 = 状态行 + 消息头 + 空行 + 消息体  \n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br")])]),r("p",[t._v("浏览器获得响应数据后，将其提取并显示在屏幕上，如果网页中包含图片，则嵌入表示图片文件标签的控制信息，浏览器显示文字时，遇到图片标签则先留出显示图片的空间，然后再次访问web服务器获取图片数据进行显示。由于每条请求消息中只能写1个URI，所以每次只能获取一个文件，获取多个文件则发送多次请求。")]),t._v(" "),r("h3",{attrs:{id:"_1-2-从dns服务器查询web服务器的ip地址"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-从dns服务器查询web服务器的ip地址"}},[t._v("#")]),t._v(" 1.2 从DNS服务器查询web服务器的IP地址")]),t._v(" "),r("p",[t._v("生成HTTP请求消息之后，浏览器委托操作系统将消息发送给Web服务器")]),t._v(" "),r("p",[t._v("IP地址/子网掩码：子网掩码前半部分全1，后半部分全0，因此将IP地址分割为网络号和主机号，主机号全0代表整个子网，全1代表广播。")]),t._v(" "),r("p",[t._v("计算机包含DNS客户端，才能向DNS服务器发送查询消息，计算机上作为DNS客户端的是DNS解析器，解析器包含在操作系统的Socket库（调用网络功能的程序组件集合）中。")]),t._v(" "),r("p",[t._v("发送查询消息的操作也不是由解析器自身执行，而是委托给操作系统内部的协议栈，协议栈执行发送消息的操作，然后通过网卡将消息发送给DNS服务器。")]),t._v(" "),r("p",[t._v("向DNS服务器发送消息时，也需要知道DNS服务器的IP地址，这个地址一般都会预设好。")]),t._v(" "),r("h3",{attrs:{id:"_1-3-dns服务器的工作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-dns服务器的工作"}},[t._v("#")]),t._v(" 1.3 DNS服务器的工作")]),t._v(" "),r("p",[t._v("基本工作：接收来自客户端的查询消息，根据消息内容返回响应。DNS服务器从域名和IP地址的对照表中查找相应的记录，并返回IP地址。")]),t._v(" "),r("p",[t._v("域名中，越靠右，层级越高，按照点号分割域名，分成一级级的域，通常将一层域的整个信息存放在一台DNS服务器中，但一台DNS服务器可以存放多个层级域的信息。")]),t._v(" "),r("p",[t._v("DNS服务器的层级关系：将负责管理下级域的DNS服务器IP地址注册到上一级DNS服务器中，以此类推，直到根域，构成DNS服务器的层级关系，再将根域的DNS服务信息保存在互联网的所有DNS服务器中，从根域向下查找子域直至找到域名相应的IP地址。")]),t._v(" "),r("blockquote",[r("p",[t._v("根域：域名最后的点号，一般不写。")])]),t._v(" "),r("p",[t._v("通过缓存可以加快DNS服务器的响应")]),t._v(" "),r("h3",{attrs:{id:"_1-4-委托协议栈发送消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-委托协议栈发送消息"}},[t._v("#")]),t._v(" 1.4 委托协议栈发送消息")]),t._v(" "),r("p",[t._v("1、创建套接字\n2、将管道连接到服务器端的套接字上\n3、收发数据\n4、断开管道并删除套接字")]),t._v(" "),r("p",[t._v("数据流通管道两端的数据出入口称为套接字，先创建套接字，再将套接字连接起来形成管道。通过IP地址和端口号可以唯一确定一个套接字。描述符可以在计算机内部确定一个套接字，IP地址和端口号可以让通信的双方确定套接字。")]),t._v(" "),r("h2",{attrs:{id:"_2-协议栈、网卡"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-协议栈、网卡"}},[t._v("#")]),t._v(" 2 协议栈、网卡")]),t._v(" "),r("h3",{attrs:{id:"_2-1-创建套接字"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-创建套接字"}},[t._v("#")]),t._v(" 2.1 创建套接字")]),t._v(" "),r("p",[t._v("协议栈：网络控制软件"),r("br"),t._v("\n网卡：网络硬件")]),t._v(" "),r("p",[t._v("浏览器、邮件等收发数据使用TCP"),r("br"),t._v("\nDNS查询等收发较短的控制数据使用UDP")]),t._v(" "),r("p",[t._v("套接字是一个概念，可以说存放了控制通信操作的控制信息（如：通信对象的IP地址、端口号、通信操作状态等）的内存空间就是套接字的实体。协议栈根据套接字中存储的信息进行下一步操作。")]),t._v(" "),r("p",[t._v("应用程序在向协议栈进行收发数据委托时需要提供包含初始控制信息的套接字描述符，协议栈才知晓通信对方信息。")]),t._v(" "),r("h3",{attrs:{id:"_2-2-连接服务器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-连接服务器"}},[t._v("#")]),t._v(" 2.2 连接服务器")]),t._v(" "),r("p",[t._v("目的：把服务器的IP地址和端口号等信息告知协议栈；客户端请求与服务器开始通信。")]),t._v(" "),r("p",[t._v("具体含义：通行双方交换控制信息，以及分配收发数据的缓冲区等通信前的准备都是连接操作的具体含义。更确切的说，连接更应该被称为准备。")]),t._v(" "),r("p",[t._v("建立连接之后，协议栈的连接操作就结束了，控制流程交回应用程序。")]),t._v(" "),r("h3",{attrs:{id:"_2-3-收发数据"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-收发数据"}},[t._v("#")]),t._v(" 2.3 收发数据")]),t._v(" "),r("p",[t._v("MTU：Maximum Transformission Unit 最大传输单元，一个网络包的最大长度，以太网中一般为1500字节（包含头部）"),r("br"),t._v("\nMSS：Maximum Segment Size 最大分段大小，不包含头部的网络包数据最大长度，一般为1460字节（TCP、IP头部一般是40字节）")]),t._v(" "),r("p",[t._v("当从应用程序收到的数据长度超过或接近MSS时，再发送数据，可以避免发送大量小包的问题；但是等待缓冲区数据长度接近MSS，需要耗费时间，同样影响响应时间，所以需要平衡两者，同时协议栈也给应用程序保留了控制发送时机的机会。")]),t._v(" "),r("p",[t._v("当数据长度超过MSS时，需要进行拆分。")]),t._v(" "),r("p",[t._v("发送方需要拆分数据包时，计算每一个数据分包的第一个字节距离原数据包起始位置的字节数，记在TCP头部的序号字段中，发送的数据分包长度无需记录，接收方用整个网络包的长度减去头部长度可得，接收方将收到的数据分包总字节数加1填入响应TCP包头部的ACK字段，用以确认响应。")]),t._v(" "),r("blockquote",[r("p",[t._v("实际中，序号从一个随机数值开始，避免通信过程可预测。")])]),t._v(" "),r("p",[t._v("TCP在得到通信对方的确认报文之前，依旧将已发送的数据保留在发送缓冲区中，如果没有得到确认报文，则会重新发送。这一补偿机制是TCP的强大之处，从而网卡、集线器、路由器等都不再有错误补偿机制。TCP会在多次重传无效之后强制结束通信，并向应用程序报错。")]),t._v(" "),r("p",[t._v("根据网络包平均往返时间动态调整ACK号等待时间")]),t._v(" "),r("p",[t._v("滑动窗口：发送一个数据包后，不等待ACK号，直接发送后续的一系列包，为避免接收方来不及处理已接收数据，接收方通过TCP头部的窗口字段将自己能接收的数据量告知发送方，即为窗口大小。")]),t._v(" "),r("p",[t._v("实际上没必要每次都向发送方更新窗口大小，发送方在每次发送数据时减去已发送的数据长度即可自行计算出当前窗口大小。所以更新窗口大小的时机应该是接收方应用程序从缓冲区取出数据的时候，此时窗口大小变大。从另一方面看，变小是由于发送方填入数据，变大是由于应用程序取出数据，变小发送方可知，变大不可知，所以需要在变大的时候更新窗口。")]),t._v(" "),r("p",[t._v("接收方在发送ACK和窗口更新时，并不会立马把包发送出去，而是等待一段时间，将其他通知合并到一起发送。连续发送ACK时，可以只发送最后一个，以为是连续的，同样，连续发送窗口更新的时候，也可以只发送最后一个窗口更新。")]),t._v(" "),r("h3",{attrs:{id:"_2-4-从服务器断开并删除套接字"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-从服务器断开并删除套接字"}},[t._v("#")]),t._v(" 2.4 从服务器断开并删除套接字")]),t._v(" "),r("h3",{attrs:{id:"_2-5-ip与以太网的包收发操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-ip与以太网的包收发操作"}},[t._v("#")]),t._v(" 2.5 IP与以太网的包收发操作")]),t._v(" "),r("p",[t._v("集线器按照以太网规则传输包，路由器按照IP规则传输包。IP协议根据目标地址判断下一个IP转发设备的位置，子网中的以太网协议将包传输到下一个转发设备。")]),t._v(" "),r("p",[t._v("TCP/IP包包含两个头部：MAC头部（以太网协议）、IP头部（IP协议）")]),t._v(" "),r("p",[t._v("发送方将接收方IP地址写入IP头部中，IP协议根据这一地址查找包的传输方向，从而找到下一个路由器的位置。之后IP协议委托以太网协议将包传输过去，IP协议查找下一个路由器的以太网地址（MAC地址）写入MAC头部，以太网协议据此传输包到下一个路由器。")]),t._v(" "),r("p",[t._v("IP协议负责寻址，以太网协议负责传输，分开就可以替换不同的传输协议。")]),t._v(" "),r("p",[t._v("包收发操作的起点是TCP模块委托IP模块发送包的操作。")]),t._v(" "),r("p",[t._v("IP地址实际上是分配给网卡的。")]),t._v(" "),r("p",[t._v("通过ARP协议查询目标路由器的MAC地址，ARP，Address Resolution Protocol，地址解析协议。ARP协议就是通过广播在子网中查询，ARP缓存可以避免每次查询的广播，但为避免保存的地址发生变化，需要定时强制删除缓存，再进行一次ARP查询。")]),t._v(" "),r("h3",{attrs:{id:"_2-6-udp协议的收发操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-udp协议的收发操作"}},[t._v("#")]),t._v(" 2.6 UDP协议的收发操作")]),t._v(" "),r("p",[t._v("向DNS服务器查询IP地址时使用的是UDP协议。")]),t._v(" "),r("p",[t._v("将从应用程序获取的数据加上UDP头部，发送给指定的IP地址即可，不需要交换控制信息，不需要建立和断开连接的步骤。")]),t._v(" "),r("p",[t._v("控制用的短数据、音视频数据")]),t._v(" "),r("h2",{attrs:{id:"_3-集线器、交换机、路由器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-集线器、交换机、路由器"}},[t._v("#")]),t._v(" 3 集线器、交换机、路由器")]),t._v(" "),r("h3",{attrs:{id:"_3-1-信号在网线和集线器中传输"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-信号在网线和集线器中传输"}},[t._v("#")]),t._v(" 3.1 信号在网线和集线器中传输")]),t._v(" "),r("p",[t._v("包独立传输：HTTP请求方法、TCP的序号和ACK、客户端与服务器的关系都与包的传输无关。")]),t._v(" "),r("h3",{attrs:{id:"_3-2-交换机的包转发操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-交换机的包转发操作"}},[t._v("#")]),t._v(" 3.2 交换机的包转发操作")]),t._v(" "),r("h3",{attrs:{id:"_3-3-路由器的包转发操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-路由器的包转发操作"}},[t._v("#")]),t._v(" 3.3 路由器的包转发操作")]),t._v(" "),r("p",[t._v("路由器忽略主机号，只匹配网络号")]),t._v(" "),r("p",[t._v("路由聚合，聚合多个子网，减少路由表中记录数量")]),t._v(" "),r("h2",{attrs:{id:"_4-接入网、网络运营商"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-接入网、网络运营商"}},[t._v("#")]),t._v(" 4 接入网、网络运营商")]),t._v(" "),r("p",[t._v("距离的不同和路由的维护方式，是互联网与家庭、公司网络之间最主要的不同点")]),t._v(" "),r("h2",{attrs:{id:"_5-防火墙、缓存服务器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-防火墙、缓存服务器"}},[t._v("#")]),t._v(" 5 防火墙、缓存服务器")]),t._v(" "),r("h2",{attrs:{id:"_6-web服务器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-web服务器"}},[t._v("#")]),t._v(" 6 Web服务器")]),t._v(" "),r("h2",{attrs:{id:"_7-http2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-http2"}},[t._v("#")]),t._v(" 7 HTTP2")]),t._v(" "),r("p",[t._v("基于SPDY协议")]),t._v(" "),r("h3",{attrs:{id:"_7-1-二进制传输"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-二进制传输"}},[t._v("#")]),t._v(" 7.1 二进制传输")]),t._v(" "),r("p",[t._v("不再是Http1.x的文本格式")]),t._v(" "),r("h3",{attrs:{id:"_7-2-多路复用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-多路复用"}},[t._v("#")]),t._v(" 7.2 多路复用")]),t._v(" "),r("h3",{attrs:{id:"_7-3-header压缩"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-header压缩"}},[t._v("#")]),t._v(" 7.3 Header压缩")]),t._v(" "),r("h3",{attrs:{id:"_7-4-服务端推送"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-服务端推送"}},[t._v("#")]),t._v(" 7.4 服务端推送")]),t._v(" "),r("h3",{attrs:{id:"_7-5-http3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-http3"}},[t._v("#")]),t._v(" 7.5 HTTP3")]),t._v(" "),r("p",[t._v("http-over-quic"),r("br"),t._v("\nQUIC协议基于UDP")]),t._v(" "),r("h2",{attrs:{id:"_8-ssl-tls工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-ssl-tls工作原理"}},[t._v("#")]),t._v(" 8 SSL/TLS工作原理")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/141258634",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考链接"),r("OutboundLink")],1)]),t._v(" "),r("blockquote",[r("p",[t._v("Secure Socket Layer、Transport Layer Security"),r("br"),t._v("\n非对称加密RSA：公钥+私钥，一个钥加密，另一个钥解密")])]),t._v(" "),r("h3",{attrs:{id:"_8-1-公私钥加密通信"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-公私钥加密通信"}},[t._v("#")]),t._v(" 8.1 公私钥加密通信")]),t._v(" "),r("p",[t._v("A、B 各有自己的公私钥（puk、prk 根据特定算法生成），prk 保存在本地，puk 传递给对方（暂且简单认为可以安全传递）。A 传递数据给 B 时，先使用 A 的 prk 加密数据摘要的哈希值 h1 形成数字签名 s1，然后将数据（密码等敏感信息也需要加密）和数字签名 s1 再使用随机生成的DES密钥（对称加密）des1 进行加密得到密文 m1，最后使用 B 的 puk 加密 des1 再连同密文 m1 传递给 B。B 收到加密后的 des1 和密文之后，先使用 B 的 prk 解密得到DES密钥 des1，使用 des1 解密密文得到数据和数字签名，本地运算得出数据摘要的哈希值 h2，再用 A 的 puk 解密转递来数字签名得到 A 计算的数据摘要的哈希值 h3，对比 h2 和 h3，以检验数据的完整性。（如此这般，中间人攻击依旧存在）")]),t._v(" "),r("p",[r("img",{attrs:{src:a(348),alt:"公私钥加密通信"}})]),t._v(" "),r("h3",{attrs:{id:"_8-2-中间人攻击"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-中间人攻击"}},[t._v("#")]),t._v(" 8.2 中间人攻击")]),t._v(" "),r("p",[t._v("中间人攻击：A、B 的 puk 需要传递给对方，如果中间人 C 截获 A、B 的 puk，把 C 的 puk 传递给 A、B，那么 A、B 就会使用 C 的 puk 加密数据，C 在之后的 A、B 传递数据时，继续截获数据，解密后篡改数据，再使用 C 的 prk 加密数据，A、B 将无法验证数据真实性，除非 A、B 当面交接 puk（显然不可行）。")]),t._v(" "),r("h3",{attrs:{id:"_8-3-ca系统"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-ca系统"}},[t._v("#")]),t._v(" 8.3 CA系统")]),t._v(" "),r("p",[t._v("CA（Certificate Authority）证书颁发机构：用以保证 puk 的真实性，CA 将自己的 puk 集成在浏览器和操作系统中，避免通过网络传输遭受中间人攻击。CA 同样基于非对称加密工作，B 将自己的 puk 和必要信息使用 CA 的 puk 加密再传递给 CA，CA 用 CA 的 prk 加密这些数据，就得出 B 的数字证书，B向A传递B的数字证书，而不是B的puk，A收到B的数字证书后，使用CA的puk解密收到的数据，才得到B的puk（同理，B也可以得到A的puk），两边即可通信数据。")]),t._v(" "),r("p",[t._v("实际中，CA认证需要收费，Web服务器会做CA认证，普通用户不会去做CA认证，所以用户浏览器想Web服务器请求安全连接，服务器传递自己的数字证书，浏览器使用CA内置的公钥解密数据得到服务器的公钥，然后使用公钥加密需要传递的数据，因此可以保证服务器的真实性，但用户端的真实性无法保证，因此需要用户账号和密码保证用户的真实性。")]),t._v(" "),r("p",[t._v("SSL/TLS工作流程（TCP建立连接之后）："),r("br"),t._v("\n1）客户端发送ClientHello消息到服务器，ClientHello消息包括：客户端支持的SSL/TLS版本、客户端支持的加密套件、session id、随机数client random"),r("br"),t._v("\n2）服务器收到ClientHello消息，选择SSL/TLS版本、加密套件，发送ServerHello消息到客户端，ServerHello消息包括：服务器支持的SSL/TLS最高版本、服务器选择的加密套件、session id、随机数server random、服务器的数字证书（使用CA的prk加密后的服务器puk和服务器必要信息）"),r("br"),t._v("\n3）客户端收到ServerHello消息后，验证服务器的数字证书（校验hash值、数字证书中服务器名称和数字证书过期时间），验证通过则生成随机数pre master，客户端使用数字证书中的服务器puk加密pre master生成密文传递给服务器，并且在本地按照F(client random + server random + pre master)的方式生成master secret作为后续对称加密通信的密钥"),r("br"),t._v("\n4）服务器收到客户端传递的消息，使用服务器的prk解密消息，得到pre master，同样按照F(client random + server random + pre master)的方式生成master secret作为后续对称加密通信的密钥"),r("br"),t._v("\n5）客户端使用master secret加密握手完成的消息发送给服务器"),r("br"),t._v("\n6）服务器使用master secret加密握手完成的消息回发给客户端，握手结束。")]),t._v(" "),r("blockquote",[r("p",[t._v("client random、server random都与时间相关联，保证了master secret一定是随机数")])])])}),[],!1,null,null,null);_.default=s.exports}}]);